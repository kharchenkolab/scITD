

#' Create a container to store all data and results for the project. You must
#' provide a params list as generated by initialize_params(). You also need to
#' provide either a seurat object or both a count_data matrix and a meta_data matrix.
#'
#' @param params list A list of the experiment params to use as generated by
#' initialize_params()
#' @param count_data sparseMatrix Matrix of raw counts with genes as rows
#' and cells as columns (default=NULL)
#' @param meta_data data.frame Metadata with cells as rows and variables
#' as columns. Number of rows in metadata should equal number of columns
#' in count matrix (default=NULL)
#' @param seurat_obj Seurat object that has been cleaned and includes the normalized,
#' log-transformed counts. The meta.data should include a column with the header
#' 'sex' and values of 'M' or 'F' if available. The metadata should
#' also have a column with the header 'ctypes' with the corresponding names of
#' the cell types as well as a column with header 'donors' that contains
#' identifiers for each donor. (default=NULL)
#' @param scMinimal environment A sub-container for the project typically
#' consisting of gene expression data in its raw and processed forms as well
#' as metadata (default=NULL)
#' @param gn_convert data.frame Gene identifier -> gene name conversions table.
#' Gene identifiers used in counts matrices should appear in the first column and
#' the corresponding gene symbols should appear in the second column. Can remain
#' NULL if the identifiers are already gene symbols. (default=NULL)
#' @param metadata_cols character The names of the metadata columns to use
#' (default=NULL)
#' @param metadata_col_nm character New names for the selected metadata columns
#' if wish to change their names. If NULL, then the preexisting column names are
#' used. (default=NULL)
#' @param label_donor_sex logical Set to TRUE to label donor sex in the meta data
#' by using expressing of sex-associated genes (default=FALSE)
#' @param winsorize_param numeric Winsorizes top gene expression per cell
#' to reduce impact of outliers (default=NULL)
#'
#' @return project container that stores sub-containers
#' for each cell type as well as results and plots from all analyses
#' @export
make_new_container <- function(params, count_data=NULL, meta_data=NULL,
                               seurat_obj=NULL, scMinimal=NULL, gn_convert=NULL,
                               metadata_cols=NULL, metadata_col_nm=NULL,
                               label_donor_sex=FALSE, winsorize_param=NULL) {

  if (!is.null(seurat_obj)) {
    scMinimal <- seurat_to_scMinimal(seurat_obj, metadata_cols=metadata_cols,
                        metadata_col_nm=metadata_col_nm)
  } else if (!is.null(count_data) & !is.null(meta_data)) {
    scMinimal <- instantiate_scMinimal(count_data, meta_data,
                                       metadata_cols=metadata_cols,
                                       metadata_col_nm=metadata_col_nm)
  } else if (is.null(scMinimal)) {
    stop("Need to provide either a seurat object or a scMinimal object or both a count matrix and meta data matrix")
  }

  # create new empty environment for all experiment data and results
  container <- new.env()
  container$scMinimal_full <- scMinimal
  container$experiment_params <- params

  if (!is.null(gn_convert)) {
    rownames(gn_convert) <- gn_convert[,1]
  }
  container$gn_convert <- gn_convert

  if (label_donor_sex) {
    container <- identify_sex_metadata(container)
  }

  if (!is.null(winsorize_param)) {
    container <- winsorize_counts(container,winsorize_param)
  }

  return(container)
}

#' Update any of the experiment parameters
#'
#' @param ctypes_use character Names of the cell types to use for the analysis
#' (default=NULL)
#' @param ncores numeric Number of cores to use (default=4)
#' @param rand_seed numeric Random seed to use (default=10)
#'
#' @return a list of the experiment parameters to use
#' @export
initialize_params <- function(ctypes_use, ncores=4, rand_seed=10) {

  if (is.null(ctypes_use)) {
    stop("You must provide the ctypes_use parameter")
  }

  params_list <- list(ctypes_use = ctypes_use,
                      ncores = ncores,
                      rand_seed = rand_seed)

  return(params_list)
}

#' Update any of the experiment parameters
#'
#' @param container environment Project container that stores sub-containers
#' for each cell type as well as results and plots from all analyses
#' @param ctypes_use character Names of the cell types to use for the analysis
#' (default=NULL)
#' @param ncores numeric Number of cores to use (default=NULL)
#' @param rand_seed numeric Random seed to use (default=NULL)
#'
#' @return the project container with updated experiment parameters in
#' container$experiment_params
#' @export
update_params <- function(container, ctypes_use=NULL,
                          ncores=NULL, rand_seed=NULL) {

  # if user/code enters a value for a param then reset its value
  if (!is.null(ctypes_use)) {
    container$experiment_params$ctypes_use <- ctypes_use
  }
  if (!is.null(ncores)) {
    container$experiment_params$ncores <- ncores
  }
  if (!is.null(rand_seed)) {
    container$experiment_params$rand_seed <- rand_seed
  }
  return(container)
}


#' Extract metadata for sex information if not provided already
#' @useDynLib scITD
#' @importFrom Rcpp sourceCpp
#'
#' @param container environment Project container that stores sub-containers
#' for each cell type as well as results and plots from all analyses
#'
#' @return the scMinimal object with sex metadata added to the metadata
#' @export
identify_sex_metadata <- function(container) {
  scMinimal <- container$scMinimal_full

  dge_sparse <- t(scMinimal$count_data)

  # get donor sums for each gene in the dataset
  donor_meta <- as.factor(scMinimal$metadata$donors)
  d_sums <- get_sums(dge_sparse,donor_meta)
  d_sums <- d_sums[2:nrow(d_sums),]

  # normalize counts
  d_sums <- t(normalize_counts(t(d_sums),scale_factor=10000))

  # convert rownames to gene symbols using provided mapping
  gn_names <- convert_gn(container, colnames(d_sums))

  y_ndx <- which(gn_names == 'RPS4Y1')
  x_ndx <- which(gn_names == 'XIST')
  y_mean <- mean(d_sums[,y_ndx])
  x_mean <- mean(d_sums[,x_ndx])

  make_note <- FALSE
  scMinimal$metadata$sex <- NA
  for (i in 1:nrow(scMinimal$metadata)) {
    d <- scMinimal$metadata$donors[i]
    if (d_sums[d,y_ndx] > y_mean && d_sums[d,x_ndx] < x_mean) {
      scMinimal$metadata$sex[i] <- 'M'
    } else if (d_sums[d,y_ndx] < y_mean && d_sums[d,x_ndx] > x_mean) {
      scMinimal$metadata$sex[i] <- 'F'
    } else {
      scMinimal$metadata$sex[i] <- 'A'
      make_note <- TRUE
    }
  }

  if (make_note) {
    print('Some assignments are ambiguous and are labeled A in the metadata.
          We recommend correcting these manually or providing the sex metadata when
          instantiating scMinimal.')
  }

  container$scMinimal_full <- scMinimal

  return(container)

}



# # add winsorize parameter to make_new_container with win_param
# winsorize_counts <- function(container,win_size=2) {
#   count_data <- container$scMinimal_full$count_data
#   metadata <- container$scMinimal_full$metadata
#   ncores <- container$experiment_params$ncores
#   for (ct in container$experiment_params$ctypes_use) {
#     print(ct)
#     counts_sub <- count_data[,metadata$ctypes==ct]
#     meta_sub <- metadata[metadata$ctypes==ct,]
#     for (d in unique(meta_sub$donors)) {
#       print(d)
#       # get counts for the donor for current cell type
#       d_counts <- counts_sub[,meta_sub$donors==d]
#
#       # normalize counts by library size
#       lib_sizes <- Matrix::colSums(d_counts)
#       d_counts <- sweep(d_counts,MARGIN=2,lib_sizes,FUN='/')
#
#       d_counts <- t(d_counts)
#
#       # winsorize - set top two highest expressing cells to third highest (for each gene)
#       tmp_out <- pagoda2:::inplaceWinsorizeSparseCols(d_counts,win_size,ncores)
#
#       d_counts <- t(d_counts)
#
#       # transform back to count space
#       d_counts <- sweep(d_counts,MARGIN=2,lib_sizes,FUN='*')
#       d_counts <- round(d_counts)
#
#       # replace info in count_data
#       count_data[rownames(d_counts),colnames(d_counts)] <- d_counts
#     }
#   }
#   # ensure cells are ordered correctly matching metadata
#   count_data <- count_data[,rownames(metadata)]
#
#   container$scMinimal_full$count_data <- count_data
#
#   return(container)
# }


winsorize_counts <- function(container,winsorize_param) {
  # get function from splatter
  inplaceWinsorizeSparseCols <- utils::getFromNamespace("inplaceWinsorizeSparseCols", "pagoda2")
  ncores <- container$experiment_params$ncores

  count_data <- container$scMinimal_full$count_data
  lib_sizes <- Matrix::colSums(count_data)
  count_data <- sweep(count_data,MARGIN=2,lib_sizes,FUN='/')
  tmp <- inplaceWinsorizeSparseCols(count_data,winsorize_param,ncores)
  count_data <- sweep(count_data,MARGIN=2,lib_sizes,FUN='*')
  count_data <- round(count_data)

  container$scMinimal_full$count_data <- count_data
  return(container)
}

























